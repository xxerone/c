#include <stdio.h>

void swap(int a, int b);
void swap_abbr(int * a, int * b); 
void changeArray(int* ptr);
int main_pointer(void)
{

	// 친구들의 주소
	/*
	[가정]
	철수 : 101호 -> 메모리 공간의 주소
	*/

	// 한글로 변수 만들기 가능, 각 문 앞에 암호가 걸려있음.
	int 철수 = 1; // 암호 : 1 (철수라는 변수가 가지고 있는 값) vs 주소 : 철수라는 변수가 컴퓨터 메모리 공간에 어디있는지 주소 (변수를 선언할 떈 메모리 공간에 공간을 만들고 1이라는 값을 넣는다.)
	int 민수 = 2;
	int 영희 = 3;
	printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);
	printf("영희네 주소 : %d, 암호 : %d\n", &영희, 영희);
	printf("민수네 주소 : %d, 암호 : %d\n", &민수, 민수); //실행할 때마다 메모리 공간 주소 달라짐.
	// 주소 : 아파트 101호 -> 메모리 기억 공간에 철수가 존재하는 위치가 있다. 위치를 가리키는 주소로 밑에 첫 번째 %d 출력


	// 미션맨 (미션을 수행하는 사람) -> int (정수형 변수) 주소값 통해 값을 직접 알아봄.
	// 첫 번째 미션 : 아파트의 각 집에 방문하여 문에 적힌 암호 확인.
	int* 미션맨; // 포인터 변수
	미션맨 = &철수; // 미션맨은 철수의 주소값을 가진다. 값 : 철수의 주소, 암호 : 주소에 있는 값
	printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);

	미션맨 = &영희;
	printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨); // 영희의 주소와 암호를 알아냄.

	미션맨 = &민수;
	printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);

	// 2번째 미션 : 각 암호에 3을 곱해라
	미션맨 = &철수;
	*미션맨 = *미션맨 * 3; //미션맨의 값 = 미션맨의 값 * 3
	printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);

	미션맨 = &영희;
	*미션맨 = *미션맨 * 3; //미션맨의 값 = 미션맨의 값 * 3
	printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);

	미션맨 = &민수;
	*미션맨 = *미션맨 * 3; //미션맨의 값 = 미션맨의 값 * 3. 포인터 변수는 주소값을 알고있는 변수에 찾아가서 값을 직접 바꾸고 변수에 존재하는 메모리 주소 알아올 수 있다.
	printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);


	// 스파이 -> 미션맨이 바꾼 암호에서 2를 빼라
	int* 스파이 = 미션맨; // 값
	printf("\n... 스파이가 미션 수행하는 중 ... \n\n");
	스파이 = &철수; // 주소
	*스파이 = *스파이 - 2;  // 철수 = 철수 - 2. 뺀 값을 스파이가 가리키는 주소 값에 넣기, 스파이가 간 곳의 암호 = *스파이
	printf("스파이가 방문하는 곳 주소 : %d, 암호 : %d\n", 스파이, *스파이);

	스파이 = &민수; // 주소
	*스파이 = *스파이 - 2;  // 철수 = 철수 - 2. 뺀 값을 스파이가 가리키는 주소 값에 넣기, 스파이가 간 곳의 암호 = *스파이
	printf("스파이가 방문하는 곳 주소 : %d, 암호 : %d\n", 스파이, *스파이);

	스파이 = &영희; // 주소
	*스파이 = *스파이 - 2;  // 철수 = 철수 - 2. 뺀 값을 스파이가 가리키는 주소 값에 넣기, 스파이가 간 곳의 암호 = *스파이
	printf("스파이가 방문하는 곳 주소 : %d, 암호 : %d\n", 스파이, *스파이);

	// 철수, 영희, 민수가 가지고 있는 1,2,3이라는 처음 선언된 값이 같을까? -> 값이 바뀜 (포인터는 변수의 주소값을 가지는 포인터 자체가 그 변수의 값을 직접 바꿀 수 있다.)
	printf("...\n 철수 영희 민수는 집에 오고서는 바뀐 암호를 보고 깜놀 ... ");
	printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);
	printf("민수네 주소 : %d, 암호 : %d\n", &민수, 민수);
	printf("영희네 주소 : %d, 암호 : %d\n", &영희, 영희);

	// 참고로.. 미션맨이 사는 곳의 주소는... &미션맨으로 확인
	printf("미션맨의 주소 : %d\n", &미션맨);
	printf("스파이의 주소 : %d\n", &스파이);

	// 스파이 포인터 변수 (2522124) => (2522124) 누군가의 아파트 주소
	// 미션맨 포인터 변수 (2522124) => (2522124) 누군가의 아파트 주소 (똑같이 가르킴, 2개의 포인터 변수가 한개의 메모리 주소 가르킴.) -> 값을 바꾸고 읽어올 수 있다.


	// 배열과 포인터의 관계
	// 배열?
	int arr[3] = { 5,10,15 };
	int* ptr = arr; //포인터 변수에 arr[3] 크기만큼의 배열 대입
	for (int i = 0; i < 3; i++) {
		printf("배열 arr[%d]의 값 : %d\n", i, arr[i]); //arr[i] : 실제 값
		printf("배열 arr[%d]의 값 : %d\n", i, *(arr + i)); //arr[i] : 실제 값, *(arr + i) : arr은 arr 배열이 가장 처음 시작되는 주소를 가지는데 주소로부터 i번째에 해당하는 녀석의 값을 가져옴. 위에랑 같은 문법
	}
	for (int i = 0; i < 3; i++) {
		printf("포인터 ptr[%d]의 값 : %d\n", i, ptr[i]); //포인터인데 배열 쓰는 것처럼 해도 오류 안남 -> 포인터는 배열이 가리키는 주소값을 그대로 나오고 접속해서 값 가져옴.
	}
	ptr[0] = 100;
	ptr[1] = 200;
	ptr[2] = 300;
	for (int i = 0; i < 3; i++) {
		printf("포인터 ptr[%d]의 값 : %d\n", i, ptr[i]); // 값 바꾸고 출력해도 포인터와 배열 값 다 바뀐 것은 포인턴가 배열 요소에 가서 값 그대로 바꿈. ptr과 arr은 같은 녀석
		printf("포인터 ptr[%d]의 값 : %d\n", i, *(ptr + i));
	}

	// *(ptr + i) == arr[i]. arr == arr 배열의 첫번째 값의 주소와 동일 == &arr[0] (arr[0]의 주소)
	printf("arr 자체의 값 : %d\n", arr); // 포인터가 arr 자체의 값을 가지면 1번째 주소의 값을 가지는 것이라 똑같이 값을 바꾸고 읽어올 수 있다.
	printf("arr[0]의 주소 : %d\n", &arr[0]); // 1번째 배열 값의 주소.

	//3:46:23부터!!
	printf("arr 자체의 값이 가지는 주소의 실제 값 : %d\n", *arr); //= *(arr + 0) -> 왜냐하면 *(arr + i) = arr[i]. arr 자체의 값은 주소를 가진다. 그 주소가 가지고 있는 실제 값을 찍어보는 것. 맨 처음의 위치?
	printf("arr[0]의 실제 값  %d\n", *&arr[0]); //배열 1번째 위치 값과 똑같이 나옴. 

	// *& 같이 있는 것 : 둘이 있는 것은 아무것도 없는 것과 같다. &는 주소이며 *는 그 주소의 값이기 때문에 *&은 서로 상쇄된다.
	printf("arr[0]의 실제 값  %d\n", *&*&*&*&*&*&*&arr[0]);
	printf("arr[0]의 실제 값  %d\n", arr[0]);


	//swap : a와 b의 값 바꾸기
	int a = 10;
	int b = 20;
	printf("a의 주소 : %d\n", &a);
	printf("b의 주소 : %d\n", &b);

	printf("Swap 함수 전 => a : %d, b : %d\n", a, b);
	swap(a, b); //a와 b 변수를 swap에 호풀할 때 a,b 받을 때 10, 20이라는 값만 던져준거고 a,b 자체를 던져준건 아님.
	printf("Swap 함수 후 => a : %d, b : %d\n", a, b); // 함수 밖으로 돌아오면 원래대로 되돌아옴.
	// 값에 의한 복사 (call by value) => 값만 복사한다는 의미 -> 메모리 공간에 있는 주소값 자체를 넘기면

	printf("(주소값 전달) Swap 함수 전 => a : %d, b : %d\n", a, b);
	swap_abbr(&a, &b); // 주소를 전달함.
	printf("(주소값 전달) Swap 함수 후 => a : %d, b : %d\n", a, b);


	// 포인터로 배열값 변경하기
	int arr2[3] = { 10,20,30 }; //배열일 때 arr2 자체가 주소 (그렇게 얘기했었나?)
	//changeArray(arr2); //10, 20, 30 값 가지는 배열의 3번째 값을 50으로 바꾸기. 위 주석의 사유 때문에 &가 없어도 주소를 바로 전달
	changeArray(&arr2[0]); //10이라는 값이 저장된 메모리 공간의 주소를 던짐. 배열은 연속된 주소의 배열 공간을 할당하기에 1번째 배열 항목에 해당하는 주소를 던져 3번째 위치에 있는 배열 값을 바꿈.
	for (int i = 0; i < 3; i++) {
		printf("%d\n", arr2[i]);
	}

	//scanf에서 &num 과 같이 &를 사용하는 이유?


	// 프로젝트 (전반전)

	
	// 프로젝트 (후반전)


	// 프로젝트 (연장전)

	return 0;
}

void swap(int a, int b) {
	printf("swap 함수 내 a의 주소 : %d\n", &a); // 새로운 공간에 만들어짐. 즉 main 함수 안의 a,b 공간과 swap 함수 공간의 a,b는 다름
	printf("swap 함수 내 b의 주소 : %d\n", &b);
	int temp = a;
	a = b;
	b = temp;
	printf("Swap 함수 내 => a : %d, b : %d\n", a, b);
}

void swap_abbr(int * a, int * b) { //포인터 변수를 선언해야 주소를 받을 수 있음.
	int temp = * a; // *a : 실제 값
	*a = *b;
	*b = temp;
	printf("(주소값 전달) Swap 함수 내 => a : %d, b : %d\n", *a, *b);
}

void changeArray(int* ptr) { //
	ptr[2] = 50; //3번째 값
}
